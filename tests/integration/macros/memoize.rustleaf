// Mock memoize macro implementation

enum Eval {
    Function(name, params, body),
    Class(name, field_names, field_defaults, methods),
    Variable(name),
    Call(func, args),
    Block(statements, final_expr),
    // ... other variants matching src/eval/core.rs
}

#[macro]
fn memoize(eval_node) {
    // Pattern match on the Eval IR node type
    match eval_node {
        Eval::Function(name, params, body) => {
            #[quote]
            var {{name}} = {
                var cache = {};

                fn original({{params}}) {
                    {{body}}
                }

                fn cached({{params}}) {
                    var args_key = str({{params}})
                    if cache.has(args_key) {
                        cache[args_key]
                    } else {
                        var result = original({{params}})
                        cache[args_key] = result
                        result
                    }
                }

                cached
            }
        }
        _ => {
            raise("#[memoize] can only be applied to functions")
        }
    }
}

var count = 0;
#[memoize]
fn fibonacci(n) {
    count += 1;
    if n <= 1 {
        n
    } else {
        fibonacci(n - 1) + fibonacci(n - 2)
    }
}

// Test the memoized function
var f = fibonacci(10);
assert(f == 55);
assert(count == 11);